Fulcro Reference Guide
=======================
:author: Tony Kay
:revdate: July 28, 2017
:revnumber: 1.0
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc:
:toclevels: 2
:sectlinks:
:sectanchors:
:sectnums:

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= About This Book

This book is meant to serve as a guide for Fulcro developers that have already gone
through the Developer's Guide tutorial and understand the core principles of
Fulcro. This book is organized by topic, and is not in order or importance. It
gives a greater level of detail on each topic and assumes you have at least
a passing knowledge of all of the core concepts and topics.

The first chapter does go over the core concepts to aid the reader in
additional clarifications about the model and design critical to Fulcro.

= Core Concepts

== Immutable Data Structures

Many of the most interesting and compelling features of Fulcro are directly or
indirectly enabled (or made simple) by the use of persistent data structures
that are a first-class citizen of the language.

In imperative programming languages like Java and Javascript you have no idea what
a function or method might do to your program state:

[source,java]
-----
Person p = new Person();

doSomethingOnAnotherThread(p);

p.fumble();

// did p just change??? Did I just cause a race condition???
-----

This leads to all sorts of subtle bugs and is arguable the source of many problems
in software today. What if `Person` couldn't change and you instead had to copy
instead if you wanted to modify?

[source,java]
-----
Person p = new Person();

doSomethingOnAnotherThread(p);

Person q = p.fumble();

// p is definitely unchanged, but q could be different
-----

Now you can reason about what will happen. The other thread will see `p` exactly as
it was when you (locally) reasoned about it. Furthermore, `q` cannot be affected
because if `p` is truly "read-only" then I still know what it is when I use it to
derive `q` (the other thread can't modify it either).

In order to derive these benefits, you need to either write objects that enforce
this behavior (which is highly inconvenient and hard to make efficient
in imperative langauges), or use a programming language that supplies the ability
to do so as a first-class feature.

Another benefit is that persistent data structures can do *structural sharing*. Basically
the new version of a map, vector, list, or set can use references to point to any
parts of the old version that are still the same in the new version. This means,
for example, that adding an element to the head of a list that had 1,000,000 entries
(where only one is being changed) is still a constant time operation!

Here are some of the features in Fulcro that result from using persistent data structures:

. A Time-travel UI history viewer that consumes little space.
. Extremely efficient detection of data changes that affect the UI (can be ref compare instead of data compare)
. Really effective "Pure Rendering"

== Pure Rendering

Fulcro uses Facebook's React to accomplish updates to the browser DOM. React, in
concept, is really simple:

Render is a function you make that generates a data structure known as the
VDOM (a lightweight virtual DOM)

. On The first "frame", the real DOM is made to match this data structure.
. On every subsequent frame, render is used to make a new VDOM. React
compares the prior VDOM (which is cached) to the new one, and then applies the
changes to the DOM.

The cool realization the creators of React had was that the DOM operations
that are slow and heavy, but there are efficient ways to figure out what
needs to be changed via the VDOM without you having to write a bunch of
controller logic.

Now, because React lives in a mutable space (Javascript), it allows all sorts of things
that can embed "rendering logic" within a component. This sounds like a good
idea to our OOP brains, but consider this:

What if you could have a complete snapshot of the state of your application, pass
that to a function, and have the screen just "look right". Like writing a 2D game: you
just redraw the screen based on the new "state of the world". All of the sudden your
mind shifts away from "bit twiddling" to thinking more about the representation
of your model with minimal data!

That is what we mean by "pure rendering".

[ditaa, target=rendering]
....

   /-------\   /-------\   /-------\   /-------\
   | state |-->| state |-->| state |-->| state |
   \-------/   \-------/   \-------/   \-------/
       |           |           |           |
       |render     |render     |render     |render
       |           |(diff)     |(diff)     |(diff)
       v           v           v           v
   /-------\   /-------\   /-------\   /-------\
   |  DOM  |   |  DOM  |   |  DOM  |   |  DOM  |
   \-------/   \-------/   \-------/   \-------/
....


Here's an example to whet your appetite: Nested check-boxes.
In imperative programming each checkbox has it's own state, and when we want a "check all"
we end up writing nightmares of logic to make sure the thing works right because we're
having to *store a mutable value* into an object that then does the rendering.
Then we play with it and find out we
forgot to handle that event where some sub-box gets unchecked to
fire an event to ensure to uncheck the "select all"...oh wait, but when I do that
it accidentally fires the event from "check all" which unchecks everything
and then goes into an infinite loop!

What a mess! Maybe you eventually figure out something that's tractable, but
that extra bit of state in the "check all" is definitely the source of bugs.

Here's what you do in pure rendering with immutable data:

Each sub-item checkbox is a simple data structure with a `:checked?` key that has a boolean
value. You use that to directly tell the checkbox what it's state should be
(and React enforces that...making it impossible for the UI to draw it any
differently)

```
(def state {:items [{:id :a :checked? true} {:id :b :checked? false} ...]})
```

For a "state of the world", these are read-only. (you have to make a "new
state of the world" to change one). When you render, the state of the
check-all is just the conjunction of it's children's `:checked?`:

[source,clojure]
----
(let [all-checked (every? :checked? (get state :items)]
   (dom/input #js {:checked all-checked}))
----

The check-all button would have *no application state at all*, and React will
force it to the correct state based on the calculated value.
When the sub-items change, a new "state of the world"
is generated with the altered item:

```
(def next-state (assoc-in state [:items 0 :checked?] false))
```

and the *entire* UI is re-rendered (React makes this fast
using the VDOM diff), the "check all" checkbox will just be
right!

If the "check all" button is pressed, then the logic is similarly very simple:
change the state for the subitems to checked if any were unchecked, or set them
all to unchecked if they were all checked:

```
(def next-state-2
  (let [all-checked? (every? :checked? (get state :items))
        c            (not all-checked?)
        old-items    (get state :items)
        new-items    (mapv #(assoc % :checked? c) old-items)]
    (assoc state :items new-items)))
```

and again you get to pretend you're rendering an entire new frame on the screen!

You'll be continually surprised at how simple your logic gets in the UI once you
adjust to this way of thinking about the problem.

== Data-Driven

Data-driven concepts were pioneered in web development by Facebook's GraphQL and
Netflix's Falcor. The idea is quite powerful, and eliminates huge amounts of
complexity is your network communication and application development.

The basic idea is this: Your UI, which might have various versions (mobile, web, tablet)
all have different but related data needs. The prevalent way of talking to our
servers is to use REST, but REST itself isn't a very good query 'or' update
language. It creates a lot of complexity that we have to deal with in order
to do the simplest things. In the small, it is "easy". In the large, it isn't
the best fit.

Data-driven applications basically use a more detailed protocol that allows the
client UIs to specify what they need, and also typically includes a "mutation
on the wire" notation that allows the client to abstractly say what it
needs the server to do.

So, instead of `/person/3` you can instead say "I need person 3, but only their
name, age, and billing info. But in the billing info, I only need to know their
billing zip code".

Notice that this abstract expression (which of course has a syntax we're
not showing you yet) is "walking a graph". This is why Facebook calls their language
"GraphQL".

You can imagine that the person and billing info might be stored in two tables
of a database, with a to-one relationship, and our query is basically asking
to query this little sub-graph:

[ditaa,graph-query-abstract]
....
[person: age? name?]--->[billing info: zip?]
....

Modifications are done in a similar, abstract way. We model them as if
they were "function calls on the wire". Like RPC/RMI:

```
'(change-person {:id 3 :age 44})
```

but instead of actually 'calling' the function, we encode this list as
a data structure (it is a list containing a symbol and a map: the power of Clojure!) and then process that
data locally (in the back-end of the UI) and optionally also
transmit it 'as data' over the wire for server processing!

== Graph Database [[GraphDB]]

The client-side of Fulcro keeps all relevant data in a simple graph database, which
is referenced by a single top-level atom. The database itself is a persistent map.

The database should be thought of as a root-level node (the top-level map itsef),
and tables that can hold data relevant to any
particular component or entity in your program (component or entity nodes).

[ditaa,target=dbmodel]
....
+-------------------+
| prop     42       |
|                   |
| table  { ID val   |
|          ... }    |
| table  { ID val   |
|          ... }    |
|                   |
+-------------------+
....

The tables are also simple maps, with a naming convention and well-defined structure.
The name of the table is typically namespaced with the "kind" of thing you're storing,
and has a name that indicates the way it is indexed:

```
{ :person/by-id { 4    { :id 4 :person/name "Joe" }}}
;   ^      ^      ^    ^
; kind   indexed  id   entity value itself
```

=== Idents

Items are joined together into a graph using a tuple of the table name and the key of
an entity. For example, the item above is known as `[:person/by-id 4]`. Notice that this
tuple is also exactly the vector you'd need it an operation that would pull data from that
entity or modify it:

```
(update-in state-db [:person/by-id 4] assoc :person/age 33)
(get-in state-db [:person/by-id 4])
```

These tuples are known as 'idents'. Idents can be used anywhere one node
in the graph needs to point to another. If the idents (which are vectors)
'appear' in a vector, then you are creating a 'to-many' relation:

[source,clojure]
------
{ :person/by-id
    {  1  {:id 1 :person/name "Joe"
           :person/spouse [:person/by-id 4]                           <1>
           :person/children [ [:person/by-id 2] [:person/by-id 3] ] } <2>
       2  { :id 2 :person/name "Julie" }
       3  { :id 3 :person/name "Billy" }
       4  { :id 4 :person/name "Heather"
            :person/spouse [:person/by-id 1]}}                        <3>
------

<1> A to-one relation to Joe's spouse (Heather)
<2> A to-many relation to Joe's kids
<3> A to-relation back to Joe from Heather

Notice in the example above that Joe and Heather point at each other. This creates
a 'loop' in the graph. This is perfectly legal. Graphs can contain loops. The
table in the example contains 4 nodes.

=== A Complete Database

The client database treats the 'root' node as a special set of non-table properties
in the top of the database map. Thus, an entire state database with 'root node'
properties might look like this:

[source,clojure]
------
{ :people [ [:person/by-id 1] [:person/by-id 2]                       <1>
            [:person/by-id 3] [:person/by-id 4] ]
  :person/by-id                                                       <2>
    {  1  {:id 1 :person/name "Joe"
           :person/spouse [:person/by-id 4]
           :person/children [ [:person/by-id 2] [:person/by-id 3] ] }
       2  { :id 2 :person/name "Julie" }
       3  { :id 3 :person/name "Billy" }
       4  { :id 4 :person/name "Heather"
            :person/spouse [:person/by-id 1]}}
------

<1> A root property called `:people` that points to all of the people nodes
<2> The people table that contains the people nodes.

The above data structure can now be thought of as a graph database looking like this:

[ditaa,target=dbgraph]
....
root                [:person/by-id 1] <----+
+-----------+      +-----------------+     |
|           |      | id 1            |     |
| people    |-+--->| name "Joe"      |     |
|           | | +----spouse          |     |
|           | | |  | children ---------+------+
+-----------+ | |  +------------------     |  |
              | |                          |  |
              +-+->[:person/by-id 2]       |  |
              |    +-----------------+     |  |
              |    | id 2            |     |  |
              |    | name "Julie     |     |  |
              |    | spouse ---------------+  |
              |    +------------------        |
              |                               |
              +--> [:person/by-id 3] <--------+
              |    +-----------------+        |
              |    | id 3            |        |
              |    | name "Billie"   |        |
              |    |                 |        |
              |    +-----------------+        |
              |                               |
              +--> [:person/by-id 4] <--------+
                   +-----------------+
                   | id 4            |
                   | name "Heather"  |
                   |                 |
                   +-----------------+
....

This makes for a very compact representation of a graph with an arbitrary number of nodes and edges.
All nodes but the special "root node" live in tables. The root node itself is special because
it is the storage location for both root properties *and* for the tables themselves.

IMPORTANT: Since the root node and the tables containing other nodes are merged
together into the same overall map it is generally important that you use
care when storing things so as not to accidentally collide on a name. Larger programs
should adopt the convention to namespace all keywords.

=== A Special Note about The Client-Side Database

The graph database on the client is the most central and key concept to understand in Fulcro. Remember
that we are doing pure rendering. This means that the UI is simply a function transforming this
graph database into the the UI.

There are two primary things to write in Fulcro: the UI and the mutations. The UI pulls data from
this database and displays it. The mutations evolve this database to a new version.
Every interaction that changes the UI should be thought of as a *data manipulation*. You're making
a new *state of the world* that your pure renderer turns into DOM.

The graph format of the database means that your data manipulation, the main dynamic thing in
the entire application, is simplified down to updating properties/nodes, which themselves
live at the top of the state atom or are only 2-3 levels deep:

```
; change the root list of people, and modify the name and age of person 2
(swap! state (fn [s]
               (-> s
                 (assoc :people [[:people/by-id 1] [:people/by-id 2]])
                 (assoc-in [:people/by-id 2 :person/name] "George")
                 (assoc-in [:people/by-id 2 :person/age] 33))))
```

For the most part the UI takes care of itself. Clojure has very good functions for manipulating
maps and vectors, so even when your data structures get more complex you task is still about
as simple as it can be.

=== Client Database Naming Conventions

To avoid collisions in your database, the following naming conventions are recommended for
use in the Fulcro client-side graph database:

[horizontal]
*UI-only Properties*:: `:ui/name`. These are special in that they never end up in server queries
derived from components. Can be used on any node to hold UI-only state. Not needed if the node itself
is not involved with server interaction.
*Tables*:: `:entity-type/index-indicator`. Examples: `:person/by-id` or `:graph/by-type`
*Root properties*:: `:root/prop-name`
*Targeted Loads*:: Loads temporarily place their results in root. Targeting relocates them. If you've followed the
other naming conventions, then these can elide a namespace if that facilitates server interactions.
*Node properties*:: `:entity-type/property-name`. Examples: `:person/name` or `:graph/data`


= Component Rendering

The core of DOM rendering is taken care of by simple factory functions that
generate the core VDOM elements. These stand-ins are ultimately what React
uses to generate, diff, and update the real DOM.

So, there are functions for every possible HTML5 element. These are in the
`om.dom` namespace, and take a Javascript map for attributes (this gives
optimal performance, since React wants to consume Javascript data):

```
(dom/div #js { :className "some-class" }
  (dom/ul nil
    (dom/li ...)))
```

Remember that this (nested) call of functions results in a representation of
what you'd like to end up on the screen.

The next level of abstraction you can use to render things is simply a function.
Combining more complex bits of UI into a function is a great way to group
re-usable nested DOM:

```
(defn my-header []
  (dom/div #js { :className "some-class" }
    (dom/ul nil
      (dom/li ...))))
```

== The `defui` Macro

The `defui` macro generates a React component. It is 100% compatible with the React ecosystem. The macro is intended
to look a bit like a class declaration, and borrows generation notation style from `defrecord`. There is no
minimum required list of methods (e.g. you don't even have to define `render`). This latter fact is useful
for cases where you want a component for server queries and database normalization, but not for rendering.

=== React (Object) methods

`defui` is aware of the following React-centric methods, which you can override:

```
(defui MyComponent
  Object
  (initLocalState [this] ...)
  (shouldComponentUpdate [this next-props next-state] ...)
  (componentWillReceiveProps [this next-props] ...)
  (componentWillUpdate [this next-props next-state] ...)
  (componentDidUpdate [this prev-props prev-state] ...)
  (componentWillMount [this] ...)
  (componentDidMount [this] ...)
  (componentWillUnmount [this] ...)
  (render [this] ...))
```

See <<ReactLifecycle, React Lifecycle Examples>> for some specific examples, and the React documentation for a complete description of each of these.

NOTE: Fulcro does override `shouldComponentUpdate` to short-circuit renders of a component whose props have not changed. You
generally do *not* want to change this to make it render more frequently; however, when using Fulcro with
libraries like D3 that want to "own" the portion of the DOM they render you may need to make it so that
React never updates the component once mounted (by returning `false` always). The Developer's Guide shows an example
of this in the UI section.

=== The `static` Protocol Qualifier

`defui` supports implementations of protocols in a `static` context. It basically
means that you'd like the methods you're defining to go on the class (instead of instance), but conform to the
given protocol. There is no Java analogue for this, but in Javascript the classes themselves are open.

WARNING: Since there is no JVM equivalent of implementing `static` methods, a hack is used internally where the
protocol methods are placed in metadata on the resulting symbol. This is the reason functions like
`get-initial-state` exist. Calling the protocol (e.g. `initial-state`) in Javascript will work, but if you
try that when doing server-side rendering on the JVM, it will blow up.

=== IQuery and Ident

There are two core protocols for supporting a component's data in the graph database. They work in tandem to
find data in the database for the component, and also to take data (e.g. from a server response or initial state) and
normalize it into the database.

Both of these protocols *must* be declared *static*. The reason for this is initial normalization and query: The
system has to be able to ask components about their ident and query generation in order to turn a tree of data
into a normalized database.

[ditaa,target=queryidentoperation]
....

Tree of Data --> Component-based Query/Ident --> Normalized Data


Normalized Data --> Component Query --> Tree of UI Data

....

Queries *must* be composed towards the root component (so you end up with a UI query that can pull the entire
tree of data for the UI).

```
(defui ListItem
  static om/IQuery
  (query [this] [:db/id :item/label])
  static om/Ident
  (ident [this props] [:list-item/by-id (:db/id props)])
  ...)

(defui List
  static om/IQuery
  (query [this] [:db/id {:list/items (om/get-query ListItem)}])
  static om/Ident
  (ident [this props] [:list/by-id (:db/id props)])
  ...)

;; queries compose up to root
```

==== Notes on the IQuery Protocol

Even though the method itself is declared statically, there are some interesting things about the `query` method:

- Once mounted, a component can have a dynamic query. This means calling `(om/get-query this)` will return either
the static query, or whatever has been set on that component via `(om/set-query! ...)`.
- The `get-query` accessor method not only helps with server-side invocation, it annotates the query with
metadata that includes the component info. This is what makes normalization work.

Some rules about the query itself:

- A query *must not* be stolen from another component (*even* if it seems more DRY):
+
```
(defui PersonView1
  static om/IQuery
  (query [this] (om/get-query PersonView2)) ;; WRONG!!!!
```
+
This is wrong because the query will end up annotated with `PersonView2`'s metadata. Never use the return
value of `get-query` as the return value for your own `query`.
- The query will be structured with joins to follow the UI tree. In this manner the render and query
follow form. If you query for some subcomponent's data, then you should pass that data to that
component's factory function for rendering.

==== Notes on the Ident Protocol

The ident of a component is often needed in mutations, since you're always manipulating the graph. To avoid
typos, it is generally recommended that you write a function like this:

```
(defn person-ident [id-or-props]
  (if (map? id-or-props)
    [:person/by-id (:db/id id-or-props)]
    [:person/by-id id-or-props]))
```

and use that in both your component's ident implementation and all of your mutations:

```
(defui Person
  static om/Ident
  (ident [this props] (person-ident props)))

...

(defmutation change-name [{:keys [id name]}]
  (action [{:keys [state]}]
    (let [name-path (conj (person-ident id) :person/name)]
      (swap! state assoc-in name-path name))))
```

==== How Normalization Works

The function `om/tree-db` is the workhorse that turns an incoming tree of data into normalized data (which can then
be merged into the overall database).

Imagine an incoming tree of data:

```
{ :people [ {:db/id 1 :person/name "Joe" ...} {:db/id 2 ...} ... ] }
```

and the query:

```
[{:people (om/get-query Person)}]
```

which expands to:
```
[{:people [:db/id :person/name]}]
          ^ metadata {:component Person}
```

`tree->db` recursively walks the data structure and query:

- At the root, it sees `:people` as a root key and property. It remembers it will be writing `:people` to the root.
- It examines the value of `:people` and finds it to be a vector of maps. This indicates a to-one relationship.
- It examines the metadata on the subquery of `:people` and discovers that the entries are represented by
the component `Person`
- For each map in the vector, it calls the `ident` function of `Person` (which it found in the metadata) to get a
database location. It then places the "person" values into the result via `assoc-in` on the ident.
- It replaces the entries in the vector with the idents.

If the metadata was missing then it would assume the person data did not need normalization. This is why it is
critical to compose queries correctly. The query and tree of data must have a parallel structure, as should the
UI. This actually makes it relatively easy to cross-check your work. In general, you can glance at a component
for problems as described in the comments below:

```
(defui Component
   static om/Ident
   (ident [this props] (component-ident props)) ; most components should have an ident. Must be static.
   static om/IQuery
   (query [this] [:prop {:join (om/get-query JoinComponent)}]) ;children are composed via a join. Static.
   Object
   (render [this]
     (let [{:keys [prop join]} (om/props this)] ; The destructuring and query match. You won't get data you don't ask for.
       (ui-join-component join) ; The joined component's data is passed to it for rendering.
       ...))
```

NOTE: A common question is "why can't this be generated for me, since it has such a predictable structure?" The answer
is that it could probably be made shorter for many cases, but overall generality of syntax would be lost. For example
assume you invented something like `(defcomponent X :prop :join JoinComponent (render [prop join] (ui-join-component join)))`. You
could probably make a macro that could parse that successfully and turn it into the correct thing, but it gets more
complicated when you also want to support react lifecycle, ident, etc. You are always free to invent such macros, but
for clarity we currently supply just the most general version.

==== Normalization: Initial State, Server Interations, and Mutations

The process described above is how most data interactions occur. At startup the `InitialAppState` supplies data that
exactly matches the tree of the UI. This gives your UI some initial state to render. The normalization mechanism
described above is exaclty what happens to that initial tree when it is detected by Fulcro at startup.

Network interactions send a UI-based query (which remember is annotated with the components). The query is
remembered and when a response tree of data is received (which must match the tree structure of the query), the
normalization process is applied and the resulting normalized data is merged with the database.

If using websockets, it is the same thing: A server push gives you a tree of data. You could hand-normalize that data,
but actually if you know the structure of the incoming data you can easily generate a client-side query (using
`defui`) that can be used in conjunction with `om/tree->db` to normalize that incoming data.

Mutations can do the same thing. If a new instance of some entity is being generated by the UI as a tree of data, then
the query for that UI component can be used to turn it into normalized data that can be merged into the state
within the mutation.

Some useful functions to know about:

- `fulcro.core/merge-component` - A utility function for merging new instances of a (possibly recursive) entity state into
the normalized database. Usable from within mutations.
- `fulcro.core/merge-state!` - A utility function for merging out-of-band (e.g. push notification) data into your application.
Includes ident integration options, and honors the Fulcro merge clobbering algorithm (if the query doesn't ask for it,
then merge doesn't affect it). Also queues rendering for affected components (derived from integration of idents). Generally
*not* used within mutations (use `merge-component` and `integrate-ident!` instead).
- `om.next/tree->db` - General utility for normalizing data via a query and chunk of data.
- `fulcro.core/integrate-ident!` - A utility for adding an ident into existing to-one and to-many relations in your database.
Can be used within mutations.
- `fulcro.client.util/deep-merge` - An implementation of merge that is recursive


== Factories

Factories are how you generate React elements (the virtual DOM nodes) from your React classes. You
make a new factory using `om.next/factory`:

```
(def ui-component (om/factory MyComponent {:keyfn f :validator v :instrument? true}))
```

There are 3 supported options to a factory:

[horizontal]
`:keyfn`:: A function from `props` to a React key. Should generally be supplied to ensure React rendering can properly diff.
`:validator`:: A function from props to boolean. If it returns false then an assertion will be thrown at runtime.
`:instrument?`:: A boolean. If true, it indicates that Om Next's instrumentation should be enabled on the component.
Instrumentation is a function you can install on the reconciler that wraps component `render` allowing you to add
measurement and debugging code to your component's rendering.

== Render and Props

Properties are always passed to a component factory as the first argument. The properties can be accessed
from within `render` by calling `om.next/props` on the parameter passed to `render` (typically named `this`
to remind you that it is a reference to the instance itself).

In components with queries there is a strong correlation between the query (which must join the child's query),
props (from which you must extract the child's props), and calling of the child's factory
(to which you must pass the child's data).

If you are using components that do not have queries, then you may pass whatever properties you deem useful.

Details about additional aspects of rendering are in the sections that follow.

=== Derived Values

It is possible that your logic and state will be much simpler if your UI components derive some values at render time.
A prime example of this is the state of a "check all" button. The state of such a button is dependent on other components
in the UI, and it is *not* a separate value. Thus, your UI should compute it and not store it else it could
easily become out of sync and lead to more complex logic.

```
(defn item-checked? [item] (:checked? item))

(defui Checkboxes
  static om/IQuery
  (query [this] [{:items (om/get-query CheckboxItem)}])
  Object
  (render [this]
    (let [{:keys [items]} (om/props this)
          all-checked? (every item-checked? items)]
      (dom/div nil
        "All: " (dom/input #js {:checked all-checked? ...})
      (dom/ul nil ...))))
```

General Guidelines for Derived Values

You should consider computing a derived value when:
- The known data from the props already gives you sufficient information to calculate the value.
- The computation is relatively light.

Some examples where UI computation are effective, light, or even necessary:

- Rendering an internationalized value. (e.g. `tr`)
- Rendering a check-all button
- Rendering "row numbering" or other decorations like row highlighting

There are some trade-offs, but most significantly you generally do *not* want to compute things like the order/pagination of a list of items.
The logic and overhead in sorting and pagination often needs caching, and there are
clear and easy "events" (user clicking on sort-by-name) that make it clear when to call the mutation to update
the database. You still have to store the selected sort order, and you have to have idents pointing to the list of
items. It is possible for your "selected sort order" and list to become out of sync, but the trade-offs of sorting
in the UI are typically high, particularly when pagination is involved and large amounts of data would have
to be fed to the UI.


=== Computed Props and Callbacks

Many reusable components will need to tell their parent about some event. For example, a list item generally wants
to tell the parent when the user has clicked on the "remote" button for that item. The item itself cannot
be truly composable if it has to know details of the parent. But a parent must always know the details of
a child (it rendered it, didn't it?). As such, manipulations that affect the content of a parent should be
communicated to that parent for processing. The mechanism for this is identical to what you'd do in stock
React: callbacks from the child.

The one *major* difference is how you pass the callback *to* a component.

The query and data feed mechanisms that supply props to a component are capable of refreshing a child *without*
refreshing a parent. This UI optimization can pull the props directly from the database using the query, and
re-feed them to the child.

But this mechanism knows nothing about callbacks, because they are not (and should not be) stored in
the client database. Such a targeted refresh of a component cannot pass callbacks through the props
because the parent is where that is coded, but the parent may not be involved in the refresh!

So, any value (function or otherwise) that is generated on-the-fly by the parent must be passed via
`om.next/computed`. This tells the data feed system how to reconstruct the complete data should it do a targeted update.

```
(defui Child
  static om/IQuery
  (query [this] [:y])
  Object
  (render [this]
    (let [{:keys [y]} (om/props this)
          onDelete (om/get-computed this :onDelete)]
    ...))

(defui Parent
  static om/IQuery
  (query [this] [:x {:child (om/get-query Child)}])
  Object
  (render [this]
    (let [{:keys [x child]} (om/props this)
          onDelete (fn [id] (om/transact! ...))
          child-props-with-callbacks (om/computed child {:onDelete onDelete})]
      (ui-child child-props-with-callbacks))))
```

WARNING: Not understanding this can cause a lot of head scratching: The initial render will always work perfectly,
because the parent is involved. All events will be processed, and you'll thing everything is fine; however, if you
have passed a callback incorrectly it will mysteriously stop working after a (possibly unnoticeable) refresh. This
means you'll "test it" and say it is OK, only to discover you have a bug that shows up during heavier use.

=== Children

A very common pattern in React is to define a number of custom components that are intended to work in a nested fashion. So,
instead of just passing `props` to a factory, you might also want to pass other React elements. This is fully supported
in Fulcro, but can cause confusion when you first try to mix it with the data-driven aspect of the system.

==== Working with Children

Fulcro includes a few functions that are helpful when designing React components that are intended to be nested as direct
children within a single render:

[horizontal]
`(om.next/children this)`:: Returns the React children of `this`
`(fulcro.client.util/react-instance? Component instance)`:: Returns true if the given element is an instance of the given component (`defui`) class. Otherwise `nil`.
`(fulcro.client.util/first-node` Component child-seq):: Returns the first of a sequence of elements that has the given component class.

So, say you wanted to create the following kind of rendering scheme:

```
(defui Panel ...)
(def ui-panel (om/factory Panel)
(defui PanelHeader ...)
(def ui-panel-header (om/factory PanelHeader)
(defui PanelBody ...)
(def ui-panel-body (om/factory PanelBody)

(ui-panel {}
  (ui-panel-header {} "Some Heading Text")
  (ui-panel-body {}
     (dom/div nil "Some sub-DOM")))
```

The your `render` for `Panel` will need to find the header and body children:

```
(defui Panel
  Object
  (render [this]
    (let [children (om/children this)
          header (util/first-node PanelHeader children)
          body (util/first-node PanelBody children)]
      (when header
        (dom/h4 nil header))
      (when body
        (dom/div nil body)))))
```

Basically, the child or children can simply be dropped into the place where they should be rendered.

#### Mixing Data-Driven Children

At first this seems a little mind-bending, because you are in fact nesting components in the UI, but in this case
the query nesting may not exactly mimic the UI tree. A good example is a *reusable component* that renders the
"current page"

TODO: CONTINUE HERE. Bootstrap page indicator.


== Controlled Inputs

== React Lifecycle Examples [[ReactLifecycle]]

There are some common use-cases that can only be solved by working directly with the React Lifecycle methods.

Some topics you should be familiar with in React to accomplish many of these things are:

- Component references: A mechanism that allows you access to the *real* DOM of the component once it's on-screen.
- Component-local state: A stateful mechanism where mutable data is stored on the component instance.
- General DOM manipulation. The Google Closure library has your JQuery equivalents, should you need them.

=== Focusing an input

Focus is a stateful browser mechanism, and React cannot force the rendering of "focus". As such, when you need
to deal with UI focus it generally involves some interpretation, and possibly component local state. One way
of dealing with deciding when to focus is to look at a component's prior vs. next properties. This can be
done in `componentDidUpdate`. For example, say you have an item that renders as a string, but when clicked
turns into an input field. You'd certainly want to focus that, and place the cursor at the end of the
existing data (or highlight it all).

If your component had a property called `editing?` that you made true to indicate it should render as an input
instead of just a value, then you could write your focus logic based on the transition of your component's props
from `:editing?` false to `:editing?` true:

```
(defui ClickToEditField
  Object
  (componentDidUpdate [this prev-props _]
    (when (and (not (:editing? prev-props)) (:editing? (om/props this)))
      (let [input-field        (js/ReactDOM.findDOMNode (.. this -refs -edit_field))
            input-field-length (.. input-field -value -length)]
        (.focus input-field)
        (.setSelectionRange input-field input-field-length input-field-length))))
  (render [this]
    (let [{:keys [value editing?]} (om/props this)]
      (if editing?
         (dom/span #js {:onClick #(m/toggle! this :editing?) } value)
         (dom/input #js {:value value :ref "edit_field"})))))
```

NOTE: React documentation encourages a more functional form of `ref` (you supply a function instead of a string).
This example could also cache that in component local state like this:

```
(defui ClickToEditField
  Object
  (componentDidUpdate [this prev-props _]
    (when (and (not (:editing? prev-props)) (:editing? (om/props this)))
      (let [input-field        (om/get-state! this :input)
            input-field-length (.. input-field -value -length)]
        (.focus input-field)
        (.setSelectionRange input-field input-field-length input-field-length))))
  (render [this]
    (let [{:keys [value editing?]} (om/props this)]
      (if editing?
         (dom/span #js {:onClick #(m/toggle! this :editing?) } value)
         (dom/input #js {:value value :ref (fn [r] (om/set-state! this {:input r}))})))))
```

=== Taking control of the sub-DOM (D3, etc)

Libraries like D3 are great for dynamic visualizations, but they need full control
of the portion of the DOM that they create and manipulate.

In general this means that your `render` method should be called once
(and only once) to install the base DOM onto which the other library
will control.

For example, let's say we wanted to use D3 to render things. We'd first
write a function that would take the *real* DOM node and the incoming
props:

```
(defn db-render [DOM-NODE props] ...)
```

This function should do everything necessary to render the sub-dom (and
update it if the props change).

Then the general layout is:

```
(defui D3Thing
  Object
  ; make sure renders into the sub-dom on first mount
  (componentDidMount [this] (d3-render (dom/node this) (om/props this)))
  ; Never let React re-call render (which would wipe out the stateful DOM underneath)
  (shouldComponentUpdate [this next-props next-state] false)
  ; On prop changes, ask the library to re-render the sub-DOM
  (componentWillReceiveProps [this props] (d3-render (dom/node this) props))
  (render [this]
    (dom/svg #js {:style   #js {:backgroundColor "rgb(240,240,240)"}
                  :width   200 :height 200
                  :viewBox "0 0 1000 1000"})))
```

=== Dynamically rendering into a canvas

In this example we're assuming you want to keep control of the DOM. For speed,
you will generally want to use component local state (Transactions are fine for
data-driven interactions, but can easily take 10ms+ which isn't good for
high-speed graphical interactions).

You'll also typically use React refs to grab the actual low-level canvas.

A running example of this is the `component-local-state` demo in the Demos. The primary scheme is
to store the reference to the canvas DOM along with the rapidly changing data in the component local state.
Rendering for each event (e.g. mouse move in this case) can then be accomplished without triggering the
low-level query mechanisms. This gives you lightning fast interactive performance that should be equivalent
to the same kind of "stateful" rendering in Javascript.

```
(defn render-hover-and-marker [props state]
  (let [canvas (:canvas state)]
  ; render stuff on the canvas
   ...))

(defn hover-marker
  "Updates the hover location of a proposed marker using canvas coordinates. Hover location is stored in component
  local state (meaning that a low-level app database query will not run to do the render that responds to this change)"
  [child evt]
  (om/update-state! child assoc :coords (event->dom-coords evt (om/get-state child :canvas)))
  (render-hover-and-marker (om/props child) (om/get-state child)))

(defui ^:once Child
  static InitialAppState
  (initial-state [cls _] {:id 0 :size 50 :marker [0.5 0.5]})
  static om/IQuery
  (query [this] [:id :size :marker])
  static om/Ident
  (ident [this props] [:child/by-id (:id props)])
  Object
  (initLocalState [this] {:coords [-50 -50]})
  ; Remember that this "render" just renders the DOM (e.g. the canvas DOM element). The graphical rendering within the canvas is done during event handling.
  (render [this]
    (let [{:keys [size]} (om/props this)]
      (dom/canvas #js {:onMouseMove (fn [evt] (hover-marker this evt))
                       ; This is a pure React mechanism for getting the underlying DOM element.
                       ; Note: when the DOM element changes this fn gets called with nil (to help you manage memory leaks), then the new element
                       :ref         (fn [r]
                                      (when r
                                        (om/update-state! this assoc :canvas r)
                                        (render-hover-and-marker (om/props this) (om/get-state this))))}))))
```

= The Query and Mutation Language

Before reading this chapter you should make sure you've read <<GraphDB,The Graph Database Chapter>>. It details
the low-level format of the application state, and talks about general manipulation strategies and functions that
are referenced in this chapter.


== Properties

== Joins

== Unions

== Parameters

== Queries on Idents

== Link Queries

== Mutations

== The AST

=== Morphing Mutations: Adding Parameters



= Walking the Graph

NOTE: Build up a root-level query, add joins, show the walking. Show how unions affect
the returned data.

== Queries on Components

== Composition Rules

== Normalization via UI Queries

= Composing Data-Driven Components in the UI

= Initial Application State

== Nested Data Mirrors Nested Query

== Alternate Branches of Unions



= Handling Mutations

== Transactional Behavior

== Recommendations

. Write the logic as functions that operate on
specific entities in your application.
. Write your mutations as simple swaps that call (1)

== Mutation Composition

Write your mutations in terms of implementation
functions that reason about specific entities. Each
entity has an ident, so you can compose any new
mutation out of such functions with this pattern:

```
; do something to the state that represents just a thing
(defn thing-mutation-impl [thing] ...)

; in a mutation
(swap! state (fn [s]
  (-> s
      ; use ident with update-in to apply changes
      (update-in thing-ident thing-mutation-impl)
      (update-in thing-ident-2 thing-mutation-impl)
      (update-in thing-ident-3 thing-mutation-impl)
      ...)))
```

== Quoting and Unquoting

== Parameters

== Using `integrate-ident!`

== Using `merge-state!`

== Remote Mutations

=== Altering the Mutation

WARNING: You cannot rely on the values in state when
computing anything for the remote. The state was
already changed by the optimistic update (mutation
handling is a multi-pass mechanism). If you need to
rely on data as it existed at the time of
`transact!` then you *must* pass it as a parameter to the
mutation.

== Mutations that Trigger one or more Loads



= Server Construction

== Easy Server

=== Injecting Components

=== Augmenting the Ring Stack

=== Adding Extra Routes

== Modular Server

Just use new devguide chapter



= Full-Stack Operations

== Theory of Operation

. Think in graphs
. Use the UI queries to get what you need
. Startup, and on event
. Targeting Root
. Targeting A Component
. Avoiding name collisions on Root
. `:ui/*` are omitted automatically
. Writes sent before reads
. Merge "stomping" is intelligent

WARNING: React lifecycle and Load

=== Merge, Normalization, and the Query

=== Incremental Loading

. Using Without
. Loading a field

== Processing Remote Queries

=== Using `defquery-root` and `defquery-entity`

=== Datomic Tips

=== SQL Tips

== Remote Mutations

=== Using `defmutation`

=== Creating Things: Tempid Remapping

=== Returning a Value





= Advanced Om-based Parsing

For use in UI or on server.

== Top-level parsing

== Recursion

== Using the AST Directly

== Using Advanced Parsing on the Client


= UI Routing

== defrouter

== Integrating with Bidi and Pushy

== Other Uses for UI Routing

. Example of side-by-side hetero list/detail




= Bootstrap Helpers

== CSS and Icons

== Components




= Forms

== Basics

=== Declaration

=== Rendering

== Validation

=== Field Validation

=== Whole Form Validation

== Simple Submission

== Custom Submission

== File Uploads

== Custom Form Elements



= Server-side Rendering

== Generating Initial State

=== Alternate Union Branches

=== Forms

== Updating State for a Given Route



= Websockets

== Client-side Setup

== Server-side Setup

== Server Push



= Customizing the Networking

== Optional Sequential Operation

== Implementing Send

=== Merging State

=== Error Handling

== Supporting Progress Updates

== Interfacing with REST Servers


= Internationalization

== Basic Strings

== Formatted Strings

== Strings in Variables

== Extracting Strings

== Generating Translations

== Modular Locale Loading

== Polyfills



= Devcards

== Developing Component UI

== Developing Active Screens



= Support Viewer

== Submitting Support Requests

== Supplying State to the Support Viewer



= Testing

== Specifications

== Assertions

== Exceptions

== Functional Assertions

== Mocking

=== Specifying Call Count

=== Checking Order

=== Verifying Parameters

=== Limitations

. Can't mock inline, protocols, or macros
. You're always creating "partial mocks"

