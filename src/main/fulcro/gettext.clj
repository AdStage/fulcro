(ns fulcro.gettext
  "A set of functions for working with GNU gettext translation files, including translation generation tools to go
  from PO files to cljs."
  (:require [clojure.string :as str]
            [clojure.java.io :as io]
            [clojure.pprint :as pp]
            [clojure.java.shell :refer [sh]])
  (:import (java.io File)))

(defn cljs-output-dir
  "Given a base source path (no trailing /) and a ns, returns the path to the directory that should contain it."
  [src-base ns]
  (let [path-from-ns (-> ns (str/replace #"\." "/") (str/replace #"-" "_"))]
    (str src-base "/" path-from-ns)))

(defn group-chunks
  "Subdivide a translation chunk into a list of translation components, placing msgctxt/msgid/msgstr components into
  individual vectors with their corresponding values."
  [translation-chunk]
  (reduce (fn [acc line]
            (let [unescaped-newlines (str/replace line #"\\n" "\n")]
              (if (re-matches #"^msg.*" line)
                (conj acc [unescaped-newlines])
                (update-in acc [(dec (count acc))] conj unescaped-newlines))))
    [] translation-chunk))

(defn join-quoted-strings
  "Join quoted strings together.

  Parameters:
  * `strings` - a vector of strings, where the string may contain a string in \"\"

  Returns a string which is a concatenation of the quoted substrings in the vector."
  [strings]
  (reduce (fn [acc quoted-string]
            (str acc (last (re-matches #"(?ms)^.*\"(.*)\"" quoted-string)))) "" strings))

(defn group-translations
  "Group the content of a .po file by translations.

  Parameters:
  * `fname` - the path to a .po file on disk

  Returns a vector of corresponding translation components."
  [fname]
  (let [fstring            (slurp fname)
        trans-chunks       (rest (str/split fstring #"(?ms)\n\n"))
        grouped-chunks     (map str/split-lines trans-chunks)
        comment?           #(re-matches #"^#.*" %)
        uncommented-chunks (map #(remove comment? %) grouped-chunks)
        keyed-chunks       (map group-chunks uncommented-chunks)]
    (if (empty? keyed-chunks) nil keyed-chunks)))

(defn map-translation-components
  "Map translation components to translation values.

  Parameters:
  * `acc` - an accumulator into which translation key/values will be placed
  * `grouped-trans-chunk` - a vector of translation components

  Used to reduce over a vector of `grouped-trans-chunk`'s, returns a map of :msgid/:msgctxt/:msgstr to their respective
  string values."
  [acc grouped-trans-chunk]
  (reduce (fn [mapped-translation trans-subcomponent]
            (let [key   (->> trans-subcomponent first (re-matches #"^(msg[a-z]+) .*$") last keyword)
                  value (join-quoted-strings trans-subcomponent)]
              (assoc mapped-translation key value))) acc grouped-trans-chunk))

(defn map-translations
  "Map translated strings to lookup keys.

  Parameters:
  * `fname` - the path to a .po file on disk

  Returns a map of msgstr values to msgctxt|msgid string keys."
  [fname]
  (let [translation-groups  (group-translations fname)
        mapped-translations (reduce (fn [trans-maps translation]
                                      (conj trans-maps (map-translation-components {} translation)))
                              [] translation-groups)]
    (reduce (fn [acc translation]
              (let [{:keys [msgctxt msgid msgstr] :or {msgctxt "" msgid "" msgstr ""}} translation
                    msg (if (and (-> msgstr .trim .isEmpty) (-> msgid .trim .isEmpty not))
                          (do
                            (println (str "WARNING: Message '" msgid "' is missing a translation! Using the default locale's message instead of an empty string."))
                            msgid)
                          msgstr)]
                (assoc acc (str msgctxt "|" msgid) msg)))
      {} mapped-translations)))


(defn wrap-with-swap
  "Wrap a translation map with supporting clojurescript code

  Parameters:
  * `locale` - the locale which this translation targets
  * `translation` - a clojurescript map of translations
  * `ns` - the ns in which to load the translations

  Returns a string of clojurescript code."
  [& {:keys [locale translation ns]}]
  (let [trans-ns  (symbol (str ns "." locale))
        locale    (if (keyword? locale) locale (keyword locale))
        ns-decl   (pp/write (list 'ns trans-ns
                              (list :require 'fulcro.i18n)) :pretty false :stream nil)
        comment   ";; This file was generated by untangled's i18n leiningen plugin."
        trans-def (pp/write (list 'def 'translations translation) :stream nil)
        swap-decl (pp/write (list 'swap! 'fulcro.i18n/*loaded-translations* 'assoc locale 'translations) :stream nil)]
    (str/join "\n\n" [ns-decl comment trans-def swap-decl])))

(defn write-cljs-translation-file [fname translations-string]
  (println "Writing " fname)
  (spit fname translations-string))

(defn po-path [{:keys [podir]} po-file] (.getAbsolutePath (new File podir po-file)))

(defn find-po-files
  "Finds any existing po-files, and adds them to settings. Returns the new settings."
  [{:keys [podir] :as settings}]
  (assoc settings :existing-po-files (filter #(.endsWith % ".po") (str/split-lines (:out (sh "ls" (.getAbsolutePath podir)))))))

(defn gettext-missing?
  "Checks for gettext. Returns settings if all OK, nil otherwise."
  [settings]
  (let [xgettext (:exit (sh "which" "xgettext"))
        msgmerge (:exit (sh "which" "msgmerge"))]
    (if (or (not= xgettext 0) (not= msgmerge 0))
      (do
        (println "Count not find xgettext or msgmerge on PATH")
        nil)
      settings)))

(defn run
  "Run a shell command and logging the command and result."
  [& args]
  (println "Running: " (str/join " " args))
  (let [result (:exit (apply sh args))]
    (when (not= 0 result)
      (print "Command Failed: " (str/join " " args))
      (println result))))


(defn clojure-ize-locale [po-filename]
  (-> po-filename
    (str/replace #"^([a-z]+_*[A-Z]*).po$" "$1")
    (str/replace #"_" "-")))

(def i18n-defaults {:translation-ns "translations" :po-folder "i18n/msgs"})

(defn expand-settings
  "Adds defaults and some additional helpful config items"
  [{:keys [src ns po] :as settings}]
  (let [srcdir      ^File (some-> src (io/as-file))
        output-path (some-> src (cljs-output-dir ns))
        outdir      ^File (some-> output-path (io/as-file))
        podir       ^File (some-> po (io/as-file))]
    (merge i18n-defaults settings
      {:messages-pot (some-> podir (File. "messages.pot") (.getAbsolutePath))
       :podir        podir
       :outdir       outdir
       :srcdir       srcdir
       :output-path  output-path})))

(defn verify-source-folders
  "Verifies that the source folder (target of the translation cljs) and ..."
  [{:keys [^File srcdir ^File outdir] :as settings}]
  (cond
    (not (.exists srcdir)) (do
                             (println "The given source-folder does not exist")
                             nil)
    (not (.exists outdir)) (do (println "Making missing source folder " (.getAbsolutePath outdir))
                               (.mkdirs outdir)
                               settings)
    :else settings))

(defn verify-po-folders
  "Verifies that po files can be generated. Returns settings if so, nil otherwise."
  [{:keys [^File podir] :as settings}]
  (cond
    (not (.exists podir)) (do
                            (println "Creating missing PO directory: " (.getAbsolutePath podir))
                            (.mkdirs podir)
                            settings)
    (not (.isDirectory podir)) (do
                                 (println "po-folder must be a directory.")
                                 nil)
    :else settings))

(defn extract-strings
  "Extract strings from a compiled js file (whitespace optimized)."
  [{:keys [js-path po] :as settings}]
  (when-let [{:keys [existing-po-files messages-pot]
              :as   settings} (some-> settings
                                expand-settings
                                gettext-missing?
                                verify-po-folders
                                find-po-files)]
    (println "Extracting strings")
    (run "xgettext" "--from-code=UTF-8" "--debug" "-k" "-ktr:1" "-ktrc:1c,2" "-ktrf:1" "-o" messages-pot js-path)
    (doseq [po (:existing-po-files settings)]
      (when (.exists (io/as-file (po-path settings po)))
        (println "Merging extracted PO template file to existing translations for " po)
        (run "msgmerge" "--force-po" "--no-wrap" "-U" (po-path settings po) messages-pot)))))

(defn deploy-translations
  "This subtask converts translated .po files into locale-specific .cljs files for runtime string translation."
  [{:keys [src ns po] :as settings}]
  (let [{:keys [existing-po-files output-path outdir]
         :as   settings} (some-> settings
                           expand-settings
                           verify-po-folders
                           verify-source-folders
                           find-po-files)
        replace-hyphen #(str/replace % #"-" "_")
        locales        (map clojure-ize-locale existing-po-files)]
    (println "po path is: " po)
    (println "Output path is: " output-path)
    (doseq [po existing-po-files]
      (let [locale            (clojure-ize-locale po)
            translation-map   (map-translations (po-path settings po))
            cljs-translations (wrap-with-swap :ns ns :locale locale :translation translation-map)
            cljs-trans-path   (str output-path "/" (replace-hyphen locale) ".cljs")]
        (write-cljs-translation-file cljs-trans-path cljs-translations)))
    (println "Deployed translations.")))

